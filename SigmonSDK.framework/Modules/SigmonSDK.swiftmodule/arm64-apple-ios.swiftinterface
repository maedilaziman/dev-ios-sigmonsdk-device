// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios15.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name SigmonSDK
import Combine
import CommonCrypto
import CoreLocation
import CoreTelephony
import Darwin
import Dispatch
import Foundation
import MobileCoreServices
@_exported import SigmonSDK
import Swift
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import _Concurrency
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static var follow: SigmonSDK.Redirector
  public static var doNotFollow: SigmonSDK.Redirector
  public let behavior: SigmonSDK.Redirector.Behavior
  public init(behavior: SigmonSDK.Redirector.Behavior)
}
extension SigmonSDK.Redirector : SigmonSDK.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension SigmonSDK.RedirectHandler where Self == SigmonSDK.Redirector {
  public static var follow: SigmonSDK.Redirector {
    get
  }
  public static var doNotFollow: SigmonSDK.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> SigmonSDK.Redirector
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static var cache: SigmonSDK.ResponseCacher
  public static var doNotCache: SigmonSDK.ResponseCacher
  public let behavior: SigmonSDK.ResponseCacher.Behavior
  public init(behavior: SigmonSDK.ResponseCacher.Behavior)
}
extension SigmonSDK.ResponseCacher : SigmonSDK.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SigmonSDK.CachedResponseHandler where Self == SigmonSDK.ResponseCacher {
  public static var cache: SigmonSDK.ResponseCacher {
    get
  }
  public static var doNotCache: SigmonSDK.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> SigmonSDK.ResponseCacher
}
public enum PKCS7 {
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public class BlockDecryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: SigmonSDK.Padding
  @usableFromInline
  internal var worker: SigmonSDK.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: SigmonSDK.Padding, _ worker: SigmonSDK.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: SigmonSDK.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: SigmonSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
extension SigmonSDK.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: SigmonSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : SigmonSDK.RequestAdapter, SigmonSDK.RequestRetrier {
}
extension SigmonSDK.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, SigmonSDK.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (SigmonSDK.Request, SigmonSDK.Session, Swift.Error, _ completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : SigmonSDK.RequestInterceptor {
  public init(_ adaptHandler: @escaping SigmonSDK.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: SigmonSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension SigmonSDK.RequestAdapter where Self == SigmonSDK.Adapter {
  public static func adapter(using closure: @escaping SigmonSDK.AdaptHandler) -> SigmonSDK.Adapter
}
open class Retrier : SigmonSDK.RequestInterceptor {
  public init(_ retryHandler: @escaping SigmonSDK.RetryHandler)
  open func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension SigmonSDK.RequestRetrier where Self == SigmonSDK.Retrier {
  public static func retrier(using closure: @escaping SigmonSDK.RetryHandler) -> SigmonSDK.Retrier
}
open class Interceptor : SigmonSDK.RequestInterceptor {
  final public let adapters: [SigmonSDK.RequestAdapter]
  final public let retriers: [SigmonSDK.RequestRetrier]
  public init(adaptHandler: @escaping SigmonSDK.AdaptHandler, retryHandler: @escaping SigmonSDK.RetryHandler)
  public init(adapter: SigmonSDK.RequestAdapter, retrier: SigmonSDK.RequestRetrier)
  public init(adapters: [SigmonSDK.RequestAdapter] = [], retriers: [SigmonSDK.RequestRetrier] = [], interceptors: [SigmonSDK.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: SigmonSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension SigmonSDK.RequestInterceptor where Self == SigmonSDK.Interceptor {
  public static func interceptor(adapter: @escaping SigmonSDK.AdaptHandler, retrier: @escaping SigmonSDK.RetryHandler) -> SigmonSDK.Interceptor
  public static func interceptor(adapter: SigmonSDK.RequestAdapter, retrier: SigmonSDK.RequestRetrier) -> SigmonSDK.Interceptor
  public static func interceptor(adapters: [SigmonSDK.RequestAdapter] = [], retriers: [SigmonSDK.RequestRetrier] = [], interceptors: [SigmonSDK.RequestInterceptor] = []) -> SigmonSDK.Interceptor
}
public struct CFB : SigmonSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: SigmonSDK.CFB.Error, b: SigmonSDK.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: SigmonSDK.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
final public class OCB : SigmonSDK.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: SigmonSDK.OCB.Mode, b: SigmonSDK.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: SigmonSDK.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: SigmonSDK.OCB.Error, b: SigmonSDK.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: SigmonSDK.OCB.Mode = .detached)
  @inlinable public convenience init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: SigmonSDK.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
  @objc deinit
}
public struct PCBC : SigmonSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: SigmonSDK.PCBC.Error, b: SigmonSDK.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: SigmonSDK.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: SigmonSDK.AlamofireExtension<Self.ExtendedType> { get set }
}
extension SigmonSDK.AlamofireExtended {
  public static var af: SigmonSDK.AlamofireExtension<Self>.Type {
    get
    set(newValue)
  }
  public var af: SigmonSDK.AlamofireExtension<Self> {
    get
    set(newValue)
  }
}
@_inheritsConvenienceInitializers public class CompactJSONEncoder : Foundation.JSONEncoder {
  public static var shared: SigmonSDK.CompactJSONEncoder
  override public func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  public func encodeToString<T>(value: T) throws -> Swift.String where T : Swift.Encodable
  override public init()
  @objc deinit
}
final public class Checksum {
  @usableFromInline
  internal static var table32: [Swift.UInt32]
  @usableFromInline
  internal static var table32c: [Swift.UInt32]
  @usableFromInline
  internal static var table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension SigmonSDK.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
extension SigmonSDK.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: SigmonSDK.PKCS5.PBKDF2.Error, b: SigmonSDK.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: SigmonSDK.HMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : SigmonSDK.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : SigmonSDK.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> SigmonSDK.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static var crl: SigmonSDK.RevocationTrustEvaluator.Options
    public static var networkAccessDisabled: SigmonSDK.RevocationTrustEvaluator.Options
    public static var ocsp: SigmonSDK.RevocationTrustEvaluator.Options
    public static var preferCRL: SigmonSDK.RevocationTrustEvaluator.Options
    public static var requirePositiveResponse: SigmonSDK.RevocationTrustEvaluator.Options
    public static var any: SigmonSDK.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = SigmonSDK.RevocationTrustEvaluator.Options
    public typealias Element = SigmonSDK.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: SigmonSDK.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SigmonSDK.ServerTrustEvaluating where Self == SigmonSDK.RevocationTrustEvaluator {
  public static var revocationChecking: SigmonSDK.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: SigmonSDK.RevocationTrustEvaluator.Options = .any) -> SigmonSDK.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SigmonSDK.ServerTrustEvaluating where Self == SigmonSDK.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: SigmonSDK.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> SigmonSDK.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SigmonSDK.ServerTrustEvaluating where Self == SigmonSDK.PublicKeysTrustEvaluator {
  public static var publicKeys: SigmonSDK.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> SigmonSDK.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public init(evaluators: [SigmonSDK.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SigmonSDK.ServerTrustEvaluating where Self == SigmonSDK.CompositeTrustEvaluator {
  public static func composite(evaluators: [SigmonSDK.ServerTrustEvaluating]) -> SigmonSDK.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = SigmonSDK.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : SigmonSDK.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == SigmonSDK.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension SigmonSDK.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension SigmonSDK.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension SigmonSDK.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static var `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: SigmonSDK.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension SigmonSDK.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension SigmonSDK.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension SigmonSDK.AlamofireExtension where ExtendedType == Darwin.OSStatus {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension SigmonSDK.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
@available(*, renamed: "Digest")
public typealias Hash = SigmonSDK.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: SigmonSDK.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: SigmonSDK.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
open class Session {
  public static var `default`: SigmonSDK.Session
  final public let session: Foundation.URLSession
  final public let delegate: SigmonSDK.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: SigmonSDK.RequestInterceptor?
  final public let serverTrustManager: SigmonSDK.ServerTrustManager?
  final public let redirectHandler: SigmonSDK.RedirectHandler?
  final public let cachedResponseHandler: SigmonSDK.CachedResponseHandler?
  final public let eventMonitor: SigmonSDK.CompositeEventMonitor
  final public let defaultEventMonitors: [SigmonSDK.EventMonitor]
  public init(session: Foundation.URLSession, delegate: SigmonSDK.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, serverTrustManager: SigmonSDK.ServerTrustManager? = nil, redirectHandler: SigmonSDK.RedirectHandler? = nil, cachedResponseHandler: SigmonSDK.CachedResponseHandler? = nil, eventMonitors: [SigmonSDK.EventMonitor] = [])
  public convenience init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: SigmonSDK.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, serverTrustManager: SigmonSDK.ServerTrustManager? = nil, redirectHandler: SigmonSDK.RedirectHandler? = nil, cachedResponseHandler: SigmonSDK.CachedResponseHandler? = nil, eventMonitors: [SigmonSDK.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<SigmonSDK.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, parameters: SigmonSDK.Parameters? = nil, encoding: SigmonSDK.ParameterEncoding = URLEncoding.default, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.DataRequest
  open func request<Parameters>(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: SigmonSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: SigmonSDK.URLRequestConvertible, interceptor: SigmonSDK.RequestInterceptor? = nil) -> SigmonSDK.DataRequest
  open func streamRequest<Parameters>(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: SigmonSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SigmonSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, headers: SigmonSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.DataStreamRequest
  open func streamRequest(_ convertible: SigmonSDK.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SigmonSDK.RequestInterceptor? = nil) -> SigmonSDK.DataStreamRequest
  open func download(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, parameters: SigmonSDK.Parameters? = nil, encoding: SigmonSDK.ParameterEncoding = URLEncoding.default, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil, to destination: SigmonSDK.DownloadRequest.Destination? = nil) -> SigmonSDK.DownloadRequest
  open func download<Parameters>(_ convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: SigmonSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, requestModifier: SigmonSDK.Session.RequestModifier? = nil, to destination: SigmonSDK.DownloadRequest.Destination? = nil) -> SigmonSDK.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: SigmonSDK.URLRequestConvertible, interceptor: SigmonSDK.RequestInterceptor? = nil, to destination: SigmonSDK.DownloadRequest.Destination? = nil) -> SigmonSDK.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: SigmonSDK.RequestInterceptor? = nil, to destination: SigmonSDK.DownloadRequest.Destination? = nil) -> SigmonSDK.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .post, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: SigmonSDK.URLRequestConvertible, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SigmonSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .post, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: SigmonSDK.URLRequestConvertible, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SigmonSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod = .post, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: SigmonSDK.URLRequestConvertible, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SigmonSDK.UploadRequest
  open func upload(multipartFormData: @escaping (SigmonSDK.MultipartFormData) -> Swift.Void, to url: SigmonSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: SigmonSDK.HTTPMethod = .post, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.UploadRequest
  open func upload(multipartFormData: @escaping (SigmonSDK.MultipartFormData) -> Swift.Void, with request: SigmonSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SigmonSDK.UploadRequest
  open func upload(multipartFormData: SigmonSDK.MultipartFormData, to url: SigmonSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: SigmonSDK.HTTPMethod = .post, headers: SigmonSDK.HTTPHeaders? = nil, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SigmonSDK.Session.RequestModifier? = nil) -> SigmonSDK.UploadRequest
  open func upload(multipartFormData: SigmonSDK.MultipartFormData, with request: SigmonSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: SigmonSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SigmonSDK.UploadRequest
}
extension SigmonSDK.Session : SigmonSDK.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: SigmonSDK.Request)
  public func retryResult(for request: SigmonSDK.Request, dueTo error: SigmonSDK.AFError, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: SigmonSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: SigmonSDK.CTR.Error, b: SigmonSDK.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
public enum PKCS5 {
}
@_hasMissingDesignatedInitializers public class ModuleFactoryImpl {
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SigmonSDK.MD5 : SigmonSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : SigmonSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : SigmonSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : SigmonSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension SigmonSDK.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : SigmonSDK.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: SigmonSDK.URLConvertible, method: SigmonSDK.HTTPMethod, headers: SigmonSDK.HTTPHeaders? = nil) throws
}
public var BOOL_IS_IPAD: Swift.Bool
public var FLOAT_FONT_SIZE_IPAD_SMALL: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_IPAD_REGULAR: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_IPAD_LARGE: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_IPHONE_SMALL: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_IPHONE_REGULAR: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_IPHONE_LARGE: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_SMALL: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_REGULAR: CoreGraphics.CGFloat
public var FLOAT_FONT_SIZE_LARGE: CoreGraphics.CGFloat
public var FLOAT_MAX_PHOTO_SIZE_INPX: CoreGraphics.CGFloat
public var FLOAT_MAX_PHOTO_SIZE_INKB: CoreGraphics.CGFloat
public var UPLOAD_SAMPLE_FILE_SIZE: Swift.Int
public var UPLOAD_FILE_SIZE: Swift.Int
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public var ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static var reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (SigmonSDK.Reachability) -> ()
  public typealias NetworkUnreachable = (SigmonSDK.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable
    case reachableViaWiFi
    case reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: SigmonSDK.Reachability.NetworkStatus, b: SigmonSDK.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable
    case wifi
    case cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static var none: SigmonSDK.Reachability.Connection
    public static func == (a: SigmonSDK.Reachability.Connection, b: SigmonSDK.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: SigmonSDK.Reachability.NetworkReachable?
  public var whenUnreachable: SigmonSDK.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: SigmonSDK.Reachability.Connection {
    get
  }
  public var connection: SigmonSDK.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  public convenience init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  public convenience init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension SigmonSDK.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
extension SigmonSDK.HMAC {
  public convenience init(key: Swift.String, variant: SigmonSDK.HMAC.Variant = .md5) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class SMSDKMainSpeedTestUI : ObjectiveC.NSObject {
  public var sdkSpeedTestSetCredentialComm: SigmonSDK.SMSDKMainSpeedTestSetCredentialComm!
  public var sdkSpeedTestComm: SigmonSDK.SMSDKMainSpeedTestComm!
  public func delegateComm(sdkSpeedTestComm: SigmonSDK.SMSDKMainSpeedTestComm)
  public func delegateSetCredentialComm(sdkSpeedTestSetCredentialComm: SigmonSDK.SMSDKMainSpeedTestSetCredentialComm)
  @objc deinit
}
extension SigmonSDK.SMSDKMainSpeedTestUI : CoreLocation.CLLocationManagerDelegate {
  @objc dynamic public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static var none: SigmonSDK.BlockModeOption
  @usableFromInline
  internal static var initializationVectorRequired: SigmonSDK.BlockModeOption
  @usableFromInline
  internal static var paddingRequired: SigmonSDK.BlockModeOption
  @usableFromInline
  internal static var useEncryptToDecrypt: SigmonSDK.BlockModeOption
  public typealias ArrayLiteralElement = SigmonSDK.BlockModeOption
  public typealias Element = SigmonSDK.BlockModeOption
  public typealias RawValue = Swift.Int
}
public enum InvalidTokenError : Swift.CustomStringConvertible, Swift.Error {
  case decodeError(Swift.String)
  case invalidAlgorithm(Swift.String)
  case invalidSignature(Swift.String?)
  case expiredToken(Swift.String)
  case invalidNotBefore(Swift.String)
  case invalidIssuedAt(Swift.String)
  case invalidAudience(Swift.String)
  case invalidIssuer(Swift.String)
  case invalidSubject(Swift.String)
  case invalidJTI(Swift.String)
  case invalidOrMissingArgument(Swift.String)
  public var description: Swift.String {
    get
  }
}
public struct CBC : SigmonSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: SigmonSDK.CBC.Error, b: SigmonSDK.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
public protocol SMSDKMainSpeedTestSetCredentialComm {
  func setCredentialKey() -> Swift.String
  func onCompleteSetCredentialKey(data: SigmonSDK.CredentialKeyData)
}
public protocol SMSDKMainSpeedTestComm {
  func onErrorInitServer(error: Swift.String)
  func getPingSpeedTest(data: SigmonSDK.PingMeasurementData)
  func getJitterSpeedTest(data: SigmonSDK.JitterMeasurementData)
  func getLossSpeedTest(data: SigmonSDK.LossMeasurementData)
  func getDownloadSpeedTest(data: SigmonSDK.DownloadMeasurementData)
  func getUploadSpeedTest(data: SigmonSDK.UploadMeasurementData)
  func getProgressSpeedTest(data: SigmonSDK.ProgressMeasurementData)
  func onCompleteSpeedTest(history: Swift.String, errorSaveHistory: Swift.String)
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : SigmonSDK.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: SigmonSDK.AuthenticationError, b: SigmonSDK.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : SigmonSDK.RequestInterceptor where AuthenticatorType : SigmonSDK.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: SigmonSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set(newValue)
  }
  public init(authenticator: AuthenticatorType, credential: SigmonSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: SigmonSDK.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SigmonSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: SigmonSDK.SHA2.Variant) -> [Element]
  public func sha3(_ variant: SigmonSDK.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: SigmonSDK.Cipher) throws -> [Element]
  public func decrypt(cipher: SigmonSDK.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : SigmonSDK.CryptoSwiftAuthenticator
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: SigmonSDK.URLEncodedFormEncoder.ArrayEncoding, b: SigmonSDK.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SigmonSDK.URLEncodedFormEncoder.BoolEncoding, b: SigmonSDK.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: SigmonSDK.URLEncodedFormEncoder.SpaceEncoding, b: SigmonSDK.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: SigmonSDK.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: SigmonSDK.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: SigmonSDK.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: SigmonSDK.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: SigmonSDK.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: SigmonSDK.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: SigmonSDK.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: SigmonSDK.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: SigmonSDK.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: SigmonSDK.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: SigmonSDK.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: SigmonSDK.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static var afURLQueryAllowed: Foundation.CharacterSet
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64String: Swift.String) throws
}
extension SigmonSDK.Message {
  public var base64String: Swift.String {
    get
  }
}
public struct JWTPayload : Swift.Codable {
  public var issuer: Swift.String?
  public var subject: Swift.String?
  public var audience: Swift.String?
  public var expiration: Swift.Int?
  public var notBefore: Swift.Int?
  public var issueAt: Swift.Int?
  public var jwtId: Swift.String?
  public var customFields: [Swift.String : SigmonSDK.EncodableValue]?
  public static var reservedKeys: [Swift.String]
  public init()
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func checkNotBefore(allowNil: Swift.Bool) throws
  public func checkExpiration(allowNil: Swift.Bool) throws
  public func checkIssueAt(allowNil: Swift.Bool) throws
  public func checkIssuer(expected: Swift.String) throws
  public func checkSubject(expected: Swift.String) throws
  public func checkAudience(expected: Swift.String) throws
  public func checkJTI(expected: Swift.String) throws
}
final public class SHA1 {
  @usableFromInline
  internal static var digestLength: Swift.Int
  @usableFromInline
  internal static var blockSize: Swift.Int
  @usableFromInline
  internal static var hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension SigmonSDK.SHA1 : SigmonSDK.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
public enum JWTAlgorithm : Swift.CustomStringConvertible {
  case none
  case rs256(SigmonSDK.RSAKey)
  case rs384(SigmonSDK.RSAKey)
  case rs512(SigmonSDK.RSAKey)
  case hs256(Swift.String)
  case hs384(Swift.String)
  case hs512(Swift.String)
  public var description: Swift.String {
    get
  }
  public func sign(message: Swift.String) -> Swift.String?
  public func verify(base64EncodedSignature: Swift.String, rawMessage: Swift.String) throws -> Swift.Bool
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public typealias AFDataResponse<Success> = SigmonSDK.DataResponse<Success, SigmonSDK.AFError>
public typealias AFDownloadResponse<Success> = SigmonSDK.DownloadResponse<Success, SigmonSDK.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension SigmonSDK.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SigmonSDK.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SigmonSDK.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SigmonSDK.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SigmonSDK.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SigmonSDK.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension SigmonSDK.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SigmonSDK.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SigmonSDK.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SigmonSDK.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SigmonSDK.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SigmonSDK.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
extension SigmonSDK.AES : SigmonSDK.Cryptors {
  @inlinable final public func makeEncryptor() throws -> SigmonSDK.Cryptor & SigmonSDK.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> SigmonSDK.Cryptor & SigmonSDK.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
extension SigmonSDK.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension SigmonSDK.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> SigmonSDK.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension SigmonSDK.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> SigmonSDK.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension SigmonSDK.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> SigmonSDK.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
public enum SwiftyCryptoRSAKeySize : Swift.Int {
  case RSAKey64
  case RSAKey128
  case RSAKey256
  case RSAKey512
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class RSAKeyFactory : ObjectiveC.NSObject {
  public static var shared: SigmonSDK.RSAKeyFactory
  public func generateKeyPair(keySize: SigmonSDK.SwiftyCryptoRSAKeySize) -> SigmonSDK.RSAKeyPair?
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.String {
  public func decryptBase64ToString(cipher: SigmonSDK.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: SigmonSDK.Cipher) throws -> Swift.Array<Swift.UInt8>
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: SigmonSDK.ChaCha20.Error, b: SigmonSDK.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension SigmonSDK.ChaCha20 : SigmonSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension SigmonSDK.ChaCha20 {
  public struct ChaChaEncryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension SigmonSDK.ChaCha20 {
  public struct ChaChaDecryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension SigmonSDK.ChaCha20 : SigmonSDK.Cryptors {
  final public func makeEncryptor() -> SigmonSDK.Cryptor & SigmonSDK.Updatable
  final public func makeDecryptor() -> SigmonSDK.Cryptor & SigmonSDK.Updatable
}
final public class GCM : SigmonSDK.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: SigmonSDK.GCM.Mode, b: SigmonSDK.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: SigmonSDK.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: SigmonSDK.GCM.Error, b: SigmonSDK.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: SigmonSDK.GCM.Mode = .detached)
  public convenience init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: SigmonSDK.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
  @objc deinit
}
public struct DynamicKey : Swift.CodingKey {
  public var stringValue: Swift.String
  public init(stringValue: Swift.String)
  public var intValue: Swift.Int? {
    get
  }
  public init?(intValue: Swift.Int)
}
public enum HMACAlgorithm {
  case sha256
  case sha384
  case sha512
  public static func == (a: SigmonSDK.HMACAlgorithm, b: SigmonSDK.HMACAlgorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SigmonSDK.HMACAlgorithm {
  public var commonCryptoAlgorithm: CommonCrypto.CCHmacAlgorithm {
    get
  }
  public var commonCryptoDigestLength: Swift.Int32 {
    get
  }
}
public func hmac(algorithm: SigmonSDK.HMACAlgorithm, key: Foundation.Data, message: Foundation.Data) -> Foundation.Data
@_inheritsConvenienceInitializers final public class CBCMAC : SigmonSDK.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension Foundation.URLSessionConfiguration : SigmonSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension SigmonSDK.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public struct SMSDKSpeedTestHistoryResponse : Swift.Codable {
  public struct History : Swift.Codable {
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : SigmonSDK.AEAD {
  public static var kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension Foundation.URLRequest {
  public var method: SigmonSDK.HTTPMethod? {
    get
    set(newValue)
  }
  public func validate() throws
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: SigmonSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SigmonSDK.Request, didFailToCreateURLRequestWithError error: SigmonSDK.AFError)
  func request(_ request: SigmonSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: SigmonSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SigmonSDK.AFError)
  func request(_ request: SigmonSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SigmonSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: SigmonSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: SigmonSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SigmonSDK.AFError)
  func request(_ request: SigmonSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SigmonSDK.AFError?)
  func requestIsRetrying(_ request: SigmonSDK.Request)
  func requestDidFinish(_ request: SigmonSDK.Request)
  func requestDidResume(_ request: SigmonSDK.Request)
  func request(_ request: SigmonSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: SigmonSDK.Request)
  func request(_ request: SigmonSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: SigmonSDK.Request)
  func request(_ request: SigmonSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: SigmonSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SigmonSDK.Request.ValidationResult)
  func request(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Foundation.Data?, SigmonSDK.AFError>)
  func request<Value>(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Value, SigmonSDK.AFError>)
  func request(_ request: SigmonSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SigmonSDK.Request.ValidationResult)
  func request<Value>(_ request: SigmonSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SigmonSDK.AFError>)
  func request(_ request: SigmonSDK.UploadRequest, didCreateUploadable uploadable: SigmonSDK.UploadRequest.Uploadable)
  func request(_ request: SigmonSDK.UploadRequest, didFailToCreateUploadableWithError error: SigmonSDK.AFError)
  func request(_ request: SigmonSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: SigmonSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SigmonSDK.AFError>)
  func request(_ request: SigmonSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: SigmonSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SigmonSDK.Request.ValidationResult)
  func request(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Foundation.URL?, SigmonSDK.AFError>)
  func request<Value>(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Value, SigmonSDK.AFError>)
}
extension SigmonSDK.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: SigmonSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SigmonSDK.Request, didFailToCreateURLRequestWithError error: SigmonSDK.AFError)
  public func request(_ request: SigmonSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: SigmonSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SigmonSDK.AFError)
  public func request(_ request: SigmonSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SigmonSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: SigmonSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: SigmonSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SigmonSDK.AFError)
  public func request(_ request: SigmonSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SigmonSDK.AFError?)
  public func requestIsRetrying(_ request: SigmonSDK.Request)
  public func requestDidFinish(_ request: SigmonSDK.Request)
  public func requestDidResume(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: SigmonSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SigmonSDK.Request.ValidationResult)
  public func request(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Foundation.Data?, SigmonSDK.AFError>)
  public func request<Value>(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Value, SigmonSDK.AFError>)
  public func request(_ request: SigmonSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SigmonSDK.Request.ValidationResult)
  public func request<Value>(_ request: SigmonSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SigmonSDK.AFError>)
  public func request(_ request: SigmonSDK.UploadRequest, didCreateUploadable uploadable: SigmonSDK.UploadRequest.Uploadable)
  public func request(_ request: SigmonSDK.UploadRequest, didFailToCreateUploadableWithError error: SigmonSDK.AFError)
  public func request(_ request: SigmonSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: SigmonSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SigmonSDK.AFError>)
  public func request(_ request: SigmonSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: SigmonSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SigmonSDK.Request.ValidationResult)
  public func request(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Foundation.URL?, SigmonSDK.AFError>)
  public func request<Value>(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Value, SigmonSDK.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : SigmonSDK.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: SigmonSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SigmonSDK.Request, didFailToCreateURLRequestWithError error: SigmonSDK.AFError)
  final public func request(_ request: SigmonSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: SigmonSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SigmonSDK.AFError)
  final public func request(_ request: SigmonSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SigmonSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: SigmonSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: SigmonSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SigmonSDK.AFError)
  final public func request(_ request: SigmonSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SigmonSDK.AFError?)
  final public func requestIsRetrying(_ request: SigmonSDK.Request)
  final public func requestDidFinish(_ request: SigmonSDK.Request)
  final public func requestDidResume(_ request: SigmonSDK.Request)
  final public func request(_ request: SigmonSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: SigmonSDK.Request)
  final public func request(_ request: SigmonSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: SigmonSDK.Request)
  final public func request(_ request: SigmonSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SigmonSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SigmonSDK.Request.ValidationResult)
  final public func request(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Foundation.Data?, SigmonSDK.AFError>)
  final public func request<Value>(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Value, SigmonSDK.AFError>)
  final public func request(_ request: SigmonSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SigmonSDK.Request.ValidationResult)
  final public func request<Value>(_ request: SigmonSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SigmonSDK.AFError>)
  final public func request(_ request: SigmonSDK.UploadRequest, didCreateUploadable uploadable: SigmonSDK.UploadRequest.Uploadable)
  final public func request(_ request: SigmonSDK.UploadRequest, didFailToCreateUploadableWithError error: SigmonSDK.AFError)
  final public func request(_ request: SigmonSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: SigmonSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SigmonSDK.AFError>)
  final public func request(_ request: SigmonSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: SigmonSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SigmonSDK.Request.ValidationResult)
  final public func request(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Foundation.URL?, SigmonSDK.AFError>)
  final public func request<Value>(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Value, SigmonSDK.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : SigmonSDK.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((SigmonSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((SigmonSDK.Request, SigmonSDK.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((SigmonSDK.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((SigmonSDK.Request, Foundation.URLRequest, SigmonSDK.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((SigmonSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((SigmonSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((SigmonSDK.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((SigmonSDK.Request, Foundation.URLSessionTask, SigmonSDK.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((SigmonSDK.Request, Foundation.URLSessionTask, SigmonSDK.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((SigmonSDK.Request) -> Swift.Void)?
  open var requestDidFinish: ((SigmonSDK.Request) -> Swift.Void)?
  open var requestDidResume: ((SigmonSDK.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((SigmonSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((SigmonSDK.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((SigmonSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((SigmonSDK.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((SigmonSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((SigmonSDK.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, SigmonSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((SigmonSDK.DataRequest, SigmonSDK.DataResponse<Foundation.Data?, SigmonSDK.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((SigmonSDK.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, SigmonSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((SigmonSDK.UploadRequest, SigmonSDK.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((SigmonSDK.UploadRequest, SigmonSDK.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((SigmonSDK.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((SigmonSDK.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, SigmonSDK.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((SigmonSDK.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((SigmonSDK.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, SigmonSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((SigmonSDK.DownloadRequest, SigmonSDK.DownloadResponse<Foundation.URL?, SigmonSDK.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: SigmonSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SigmonSDK.Request, didFailToCreateURLRequestWithError error: SigmonSDK.AFError)
  open func request(_ request: SigmonSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: SigmonSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SigmonSDK.AFError)
  open func request(_ request: SigmonSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SigmonSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: SigmonSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: SigmonSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SigmonSDK.AFError)
  open func request(_ request: SigmonSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SigmonSDK.AFError?)
  open func requestIsRetrying(_ request: SigmonSDK.Request)
  open func requestDidFinish(_ request: SigmonSDK.Request)
  open func requestDidResume(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: SigmonSDK.Request)
  public func request(_ request: SigmonSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: SigmonSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SigmonSDK.Request.ValidationResult)
  open func request(_ request: SigmonSDK.DataRequest, didParseResponse response: SigmonSDK.DataResponse<Foundation.Data?, SigmonSDK.AFError>)
  public func request(_ request: SigmonSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SigmonSDK.Request.ValidationResult)
  open func request(_ request: SigmonSDK.UploadRequest, didCreateUploadable uploadable: SigmonSDK.UploadRequest.Uploadable)
  open func request(_ request: SigmonSDK.UploadRequest, didFailToCreateUploadableWithError error: SigmonSDK.AFError)
  open func request(_ request: SigmonSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: SigmonSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SigmonSDK.AFError>)
  open func request(_ request: SigmonSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: SigmonSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SigmonSDK.Request.ValidationResult)
  open func request(_ request: SigmonSDK.DownloadRequest, didParseResponse response: SigmonSDK.DownloadResponse<Foundation.URL?, SigmonSDK.AFError>)
  @objc deinit
}
extension SigmonSDK.Request {
  public static var didResumeNotification: Foundation.Notification.Name
  public static var didSuspendNotification: Foundation.Notification.Name
  public static var didCancelNotification: Foundation.Notification.Name
  public static var didFinishNotification: Foundation.Notification.Name
  public static var didResumeTaskNotification: Foundation.Notification.Name
  public static var didSuspendTaskNotification: Foundation.Notification.Name
  public static var didCancelTaskNotification: Foundation.Notification.Name
  public static var didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: SigmonSDK.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : SigmonSDK.EventMonitor {
  final public func requestDidResume(_ request: SigmonSDK.Request)
  final public func requestDidSuspend(_ request: SigmonSDK.Request)
  final public func requestDidCancel(_ request: SigmonSDK.Request)
  final public func requestDidFinish(_ request: SigmonSDK.Request)
  final public func request(_ request: SigmonSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: SigmonSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: SigmonSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SigmonSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SigmonSDK.AFError?)
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public enum DeviceModel : Swift.String {
  case simulator
  case iPod1
  case iPod2
  case iPod3
  case iPod4
  case iPod5
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPadAir3
  case iPad5
  case iPad6
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadPro9_7
  case iPadPro10_5
  case iPadPro11
  case iPadPro12_9
  case iPadPro2_12_9
  case iPadPro3_12_9
  case iPhone4
  case iPhone4S
  case iPhone5
  case iPhone5S
  case iPhone5C
  case iPhone6
  case iPhone6Plus
  case iPhone6S
  case iPhone6SPlus
  case iPhoneSE
  case iPhone7
  case iPhone7Plus
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case AppleTV
  case AppleTV_4K
  case unrecognized
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var isIPad: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var type: SigmonSDK.DeviceModel {
    get
  }
  @_Concurrency.MainActor(unsafe) public var id: Swift.String? {
    get
  }
}
public enum SwiftyCryptoError : Swift.Error {
  case invalidBase64String
  case invalidKeyFormat
  case invalidAsn1Structure
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case tagEncodingFailed
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension SigmonSDK.Bit {
  @inlinable internal func inverted() -> SigmonSDK.Bit {
    self == .zero ? .one : .zero
  }
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension SigmonSDK.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: SigmonSDK.BatchedCollectionIndex<Base>, rhs: SigmonSDK.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: SigmonSDK.BatchedCollectionIndex<Base>, rhs: SigmonSDK.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = SigmonSDK.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: SigmonSDK.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: SigmonSDK.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: SigmonSDK.BatchedCollection<Base>.Index) -> SigmonSDK.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: SigmonSDK.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<SigmonSDK.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<SigmonSDK.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<SigmonSDK.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> SigmonSDK.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
extension Swift.Encodable {
  public var dictionary: [Swift.String : Any]? {
    get
  }
  public var dictionaryWithConvert: [Swift.String : Any]? {
    get
  }
  public var stringJson: Swift.String? {
    get
  }
}
public var STRING_DEFAULT_FONT_REGULAR_NAME: Swift.String
public var STRING_DEFAULT_FONT_BOLD_NAME: Swift.String
public var STRING_DEFAULT_FONT_LIGHT_NAME: Swift.String
public var STRING_DEFAULT_FONT_ITALIC: Swift.String
public var STRING_DEFAULT_FONT_MEDIUM_NAME: Swift.String
public var KEY_SESSION_CONFIG: Swift.String
public var KEY_SESSION_MULTITEST: Swift.String
public enum RSAKeyType {
  case PUBLIC
  case PRIVATE
  public static func == (a: SigmonSDK.RSAKeyType, b: SigmonSDK.RSAKeyType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct RSAKeyPair {
  public var privateKey: SigmonSDK.RSAKey
  public var publicKey: SigmonSDK.RSAKey
}
public class RSAKey {
  public var key: Security.SecKey
  public var keyBase64String: Swift.String
  public var data: Foundation.Data?
  public var keyType: SigmonSDK.RSAKeyType!
  public init(key: Security.SecKey, keyBase64String: Swift.String, keyType: SigmonSDK.RSAKeyType)
  public init(base64String: Swift.String, keyType: SigmonSDK.RSAKeyType) throws
  public static func base64StringWithoutPrefixAndSuffix(pemString: Swift.String) throws -> Swift.String
  public func pemString() throws -> Swift.String
  public func format(keyData: Foundation.Data, keyType: SigmonSDK.RSAKeyType) -> Swift.String
  @objc deinit
}
extension SigmonSDK.AES {
  public convenience init(key: Swift.String, iv: Swift.String, padding: SigmonSDK.Padding = .pkcs7) throws
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : SigmonSDK.ParameterEncoder {
  public static var `default`: SigmonSDK.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: SigmonSDK.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: SigmonSDK.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension SigmonSDK.ParameterEncoder where Self == SigmonSDK.JSONParameterEncoder {
  public static var json: SigmonSDK.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> SigmonSDK.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : SigmonSDK.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SigmonSDK.URLEncodedFormParameterEncoder.Destination, b: SigmonSDK.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SigmonSDK.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: SigmonSDK.URLEncodedFormEncoder
  final public let destination: SigmonSDK.URLEncodedFormParameterEncoder.Destination
  public init(encoder: SigmonSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: SigmonSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension SigmonSDK.ParameterEncoder where Self == SigmonSDK.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: SigmonSDK.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: SigmonSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: SigmonSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> SigmonSDK.URLEncodedFormParameterEncoder
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: SigmonSDK.HKDF.Error, b: SigmonSDK.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: SigmonSDK.HMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
public struct OFB : SigmonSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: SigmonSDK.OFB.Error, b: SigmonSDK.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
extension SigmonSDK.Rabbit {
  public convenience init(key: Swift.String) throws
  public convenience init(key: Swift.String, iv: Swift.String) throws
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : SigmonSDK.PaddingProtocol {
  case noPadding
  case zeroPadding
  case pkcs7
  case pkcs5
  case iso78164
  case iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: SigmonSDK.Padding, b: SigmonSDK.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class RetryPolicy : SigmonSDK.RequestInterceptor {
  public static var defaultRetryLimit: Swift.UInt
  public static var defaultExponentialBackoffBase: Swift.UInt
  public static var defaultExponentialBackoffScale: Swift.Double
  public static var defaultRetryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod>
  public static var defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static var defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: SigmonSDK.Request, for session: SigmonSDK.Session, dueTo error: Swift.Error, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  open func shouldRetry(request: SigmonSDK.Request, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
extension SigmonSDK.RequestInterceptor where Self == SigmonSDK.RetryPolicy {
  public static var retryPolicy: SigmonSDK.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> SigmonSDK.RetryPolicy
}
open class ConnectionLostRetryPolicy : SigmonSDK.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension SigmonSDK.RequestInterceptor where Self == SigmonSDK.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: SigmonSDK.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SigmonSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> SigmonSDK.ConnectionLostRetryPolicy
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: SigmonSDK.CipherError, b: SigmonSDK.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension SigmonSDK.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: SigmonSDK.Rabbit.Error, b: SigmonSDK.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var ivSize: Swift.Int
  public static var keySize: Swift.Int
  public static var blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  public convenience init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension SigmonSDK.Rabbit : SigmonSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public var AF: SigmonSDK.Session
@usableFromInline
final internal class StreamEncryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: SigmonSDK.CipherModeWorker
  @usableFromInline
  final internal let padding: SigmonSDK.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: SigmonSDK.Padding, _ worker: SigmonSDK.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public typealias AFResult<Success> = Swift.Result<Success, SigmonSDK.AFError>
public class RSASignature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: SigmonSDK.RSASignature.DigestType, b: SigmonSDK.RSASignature.DigestType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  public convenience init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class TestCreateLogger : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public func printHelloLogger()
  @objc deinit
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
extension SigmonSDK.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: SigmonSDK.PKCS5.PBKDF1.Error, b: SigmonSDK.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5
      case sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: SigmonSDK.PKCS5.PBKDF1.Variant, b: SigmonSDK.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: SigmonSDK.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: SigmonSDK.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
open class MultipartFormData {
  public static var encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set(value)
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: SigmonSDK.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: SigmonSDK.AES.Error, b: SigmonSDK.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128
    case aes192
    case aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static var blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: SigmonSDK.AES.Variant
  @usableFromInline
  final internal let blockMode: SigmonSDK.BlockMode
  @usableFromInline
  final internal let padding: SigmonSDK.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set(value)
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set(value)
  }
  @usableFromInline
  internal static var T0: [Swift.UInt32]
  @usableFromInline
  internal static var T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static var T1: [Swift.UInt32]
  @usableFromInline
  internal static var T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static var T2: [Swift.UInt32]
  @usableFromInline
  internal static var T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static var T3: [Swift.UInt32]
  @usableFromInline
  internal static var T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static var U1: [Swift.UInt32]
  @usableFromInline
  internal static var U2: [Swift.UInt32]
  @usableFromInline
  internal static var U3: [Swift.UInt32]
  @usableFromInline
  internal static var U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: SigmonSDK.BlockMode, padding: SigmonSDK.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension SigmonSDK.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension SigmonSDK.AES : SigmonSDK.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
@_inheritsConvenienceInitializers @objc public class SMSDKMainSpeedTestMainUI : ObjectiveC.NSObject {
  @objc override dynamic public init()
  public func mainSpeedTestUI(sdkSpeedTestSetCredentialComm: SigmonSDK.SMSDKMainSpeedTestSetCredentialComm, sdkSpeedTestComm: SigmonSDK.SMSDKMainSpeedTestComm) -> SigmonSDK.SMSDKMainSpeedTestUI
  public func startSpeedTest() -> Swift.String
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: SigmonSDK.CCM.Error, b: SigmonSDK.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: SigmonSDK.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: SigmonSDK.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: SigmonSDK.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : SigmonSDK.CryptoSwiftAuthenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
public struct JWT {
  public var header: SigmonSDK.JWTHeader!
  public var payload: SigmonSDK.JWTPayload!
  public var signature: Swift.String!
  public var rawString: Swift.String!
  public init?(payload: SigmonSDK.JWTPayload, algorithm: SigmonSDK.JWTAlgorithm, header: SigmonSDK.JWTHeader? = nil)
  public init(algorithm: SigmonSDK.JWTAlgorithm, rawString: Swift.String) throws
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: SigmonSDK.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: SigmonSDK.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: SigmonSDK.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: SigmonSDK.CryptoSwiftAuthenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : SigmonSDK._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [SigmonSDK.Bit]
  public func bits() -> Swift.String
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> SigmonSDK.Cryptor & SigmonSDK.Updatable
  func makeDecryptor() throws -> SigmonSDK.Cryptor & SigmonSDK.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension SigmonSDK.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension SigmonSDK.ChaCha20 {
  public convenience init(key: Swift.String, iv: Swift.String) throws
}
public class RSAMessage : SigmonSDK.Message {
  public var data: Foundation.Data
  public var base64String: Swift.String
  required public init(data: Foundation.Data)
  required public convenience init(base64String: Swift.String) throws
  public func sign(signingKey: SigmonSDK.RSAKey, digestType: SigmonSDK.RSASignature.DigestType) throws -> SigmonSDK.RSASignature
  public func verify(verifyKey: SigmonSDK.RSAKey, signature: SigmonSDK.RSASignature, digestType: SigmonSDK.RSASignature.DigestType) throws -> Swift.Bool
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: SigmonSDK.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension SigmonSDK.Blowfish {
  public convenience init(key: Swift.String, iv: Swift.String, padding: SigmonSDK.Padding = .pkcs7) throws
}
public protocol CipherModeWorker {
  var cipherOperation: SigmonSDK.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : SigmonSDK.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : SigmonSDK.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : SigmonSDK.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : SigmonSDK.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : SigmonSDK.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : SigmonSDK.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension SigmonSDK.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension SigmonSDK.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension SigmonSDK.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SigmonSDK.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public protocol CryptoSwiftAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct EncodableValue : Swift.Codable {
  public let value: Swift.Encodable
  public func encode(to encoder: Swift.Encoder) throws
  public init(value _value: Swift.Encodable)
  public init(from decoder: Swift.Decoder) throws
}
public struct PingMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Int
  public var error: Swift.String
}
public struct JitterMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Int
  public var error: Swift.String
}
public struct LossMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Int
  public var error: Swift.String
}
public struct DownloadMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Double
  public var error: Swift.String
}
public struct UploadMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Double
  public var error: Swift.String
}
public struct ProgressMeasurementData {
  public var isComplete: Swift.Bool
  public var value: Swift.Int
  public var error: Swift.String
}
public struct CredentialKeyData {
  public var success: Swift.Bool
  public var error: Swift.String
}
@usableFromInline
final internal class StreamDecryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: SigmonSDK.CipherModeWorker
  @usableFromInline
  final internal let padding: SigmonSDK.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: SigmonSDK.Padding, _ worker: SigmonSDK.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
public struct ECB : SigmonSDK.BlockMode {
  public let options: SigmonSDK.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping SigmonSDK.CipherOperationOnBlock, encryptionOperation: @escaping SigmonSDK.CipherOperationOnBlock) throws -> SigmonSDK.CipherModeWorker
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(SigmonSDK.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: SigmonSDK.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: SigmonSDK.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: SigmonSDK.AFError.ServerTrustFailureReason.Output, options: SigmonSDK.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: SigmonSDK.URLConvertible)
  case multipartEncodingFailed(reason: SigmonSDK.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: SigmonSDK.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: SigmonSDK.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: SigmonSDK.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: SigmonSDK.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: SigmonSDK.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: SigmonSDK.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: SigmonSDK.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> SigmonSDK.AFError
}
extension SigmonSDK.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension SigmonSDK.AFError {
  public var urlConvertible: SigmonSDK.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension SigmonSDK.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: SigmonSDK.Blowfish.Error, b: SigmonSDK.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: SigmonSDK.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: SigmonSDK.Padding) throws
  @objc deinit
}
extension SigmonSDK.Blowfish : SigmonSDK.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = SigmonSDK.DataResponse<Value, SigmonSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SigmonSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SigmonSDK.ResponseSerializer
  public init<Serializer>(_ request: SigmonSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SigmonSDK.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SigmonSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SigmonSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == SigmonSDK.DataResponsePublisher<Value>.Failure, S.Input == SigmonSDK.DataResponsePublisher<Value>.Output
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension SigmonSDK.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: SigmonSDK.DataRequest, queue: Dispatch.DispatchQueue)
}
extension SigmonSDK.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DataResponsePublisher<T> where Serializer : SigmonSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SigmonSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SigmonSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = SigmonSDK.DataStreamRequest.Stream<Value, SigmonSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SigmonSDK.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SigmonSDK.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SigmonSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SigmonSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == SigmonSDK.DataStreamPublisher<Value>.Failure, S.Input == SigmonSDK.DataStreamPublisher<Value>.Output
}
extension SigmonSDK.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DataStreamPublisher<Serializer.SerializedObject> where Serializer : SigmonSDK.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: SigmonSDK.DataDecoder = JSONDecoder(), preprocessor: SigmonSDK.DataPreprocessor = PassthroughPreprocessor()) -> SigmonSDK.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = SigmonSDK.DownloadResponse<Value, SigmonSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SigmonSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SigmonSDK.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: SigmonSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SigmonSDK.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SigmonSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SigmonSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == SigmonSDK.DownloadResponsePublisher<Value>.Failure, S.Input == SigmonSDK.DownloadResponsePublisher<Value>.Output
}
extension SigmonSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DownloadResponsePublisher<T> where Serializer : SigmonSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DownloadResponsePublisher<T> where Serializer : SigmonSDK.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SigmonSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SigmonSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension SigmonSDK.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: SigmonSDK.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension SigmonSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> SigmonSDK.DownloadResponsePublisher<Foundation.URL?>
}
public class CMAC : SigmonSDK.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: SigmonSDK.CMAC.Error, b: SigmonSDK.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: SigmonSDK.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224
    case sha256
    case sha384
    case sha512
    case keccak224
    case keccak256
    case keccak384
    case keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: SigmonSDK.SHA3.Variant, b: SigmonSDK.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: SigmonSDK.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension SigmonSDK.SHA3 : SigmonSDK.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: SigmonSDK.URLRequestConvertible, with parameters: SigmonSDK.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : SigmonSDK.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SigmonSDK.URLEncoding.Destination, b: SigmonSDK.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: SigmonSDK.URLEncoding.ArrayEncoding, b: SigmonSDK.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SigmonSDK.URLEncoding.BoolEncoding, b: SigmonSDK.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SigmonSDK.URLEncoding {
    get
  }
  public static var queryString: SigmonSDK.URLEncoding {
    get
  }
  public static var httpBody: SigmonSDK.URLEncoding {
    get
  }
  public let destination: SigmonSDK.URLEncoding.Destination
  public let arrayEncoding: SigmonSDK.URLEncoding.ArrayEncoding
  public let boolEncoding: SigmonSDK.URLEncoding.BoolEncoding
  public init(destination: SigmonSDK.URLEncoding.Destination = .methodDependent, arrayEncoding: SigmonSDK.URLEncoding.ArrayEncoding = .brackets, boolEncoding: SigmonSDK.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: SigmonSDK.URLRequestConvertible, with parameters: SigmonSDK.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : SigmonSDK.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: SigmonSDK.JSONEncoding.Error, b: SigmonSDK.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SigmonSDK.JSONEncoding {
    get
  }
  public static var prettyPrinted: SigmonSDK.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: SigmonSDK.URLRequestConvertible, with parameters: SigmonSDK.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: SigmonSDK.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
extension SigmonSDK.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
final public class Poly1305 : SigmonSDK.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: SigmonSDK.Poly1305.Error, b: SigmonSDK.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct JWTHeader : Swift.Codable {
  public var algorithm: Swift.String?
  public var type: Swift.String
  public var keyId: Swift.String?
  public init(keyId: Swift.String? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_inheritsConvenienceInitializers public class CompactJSONDecoder : Foundation.JSONDecoder {
  public static var shared: SigmonSDK.CompactJSONDecoder
  override public func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  public func decode<T>(_ type: T.Type, from string: Swift.String) throws -> T where T : Swift.Decodable
  public func decode(from string: Swift.String) throws -> [Swift.String : Any]
  override public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class Base64Utils : ObjectiveC.NSObject {
  public static func base64encode(input: Foundation.Data) -> Swift.String
  public static func base64encode(input: Swift.String) -> Swift.String?
  public static func stringURISafe(input: Swift.String) -> Swift.String
  public static func base64encodeURISafe(input: Foundation.Data) -> Swift.String
  public static func base64decode(_ input: Swift.String) -> Foundation.Data?
  public static func decode(encodedString: Swift.String) -> Swift.String?
  public static func base64StringWithPadding(encodedString: Swift.String) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: SigmonSDK.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224
    case sha256
    case sha384
    case sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: SigmonSDK.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: SigmonSDK.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: SigmonSDK.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension SigmonSDK.SHA2 : SigmonSDK.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static var `default`: SigmonSDK.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  public convenience init?(host: Swift.String)
  public convenience init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping SigmonSDK.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus, b: SigmonSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
@usableFromInline
final internal class BlockEncryptor : SigmonSDK.Cryptor, SigmonSDK.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: SigmonSDK.Padding, _ worker: SigmonSDK.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension SigmonSDK.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [SigmonSDK.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: SigmonSDK.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: SigmonSDK.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> SigmonSDK.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set(newValue)
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension SigmonSDK.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension SigmonSDK.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: SigmonSDK.HTTPHeader...)
  public typealias ArrayLiteralElement = SigmonSDK.HTTPHeader
}
extension SigmonSDK.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[SigmonSDK.HTTPHeader]>
}
extension SigmonSDK.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> SigmonSDK.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = SigmonSDK.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<SigmonSDK.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[SigmonSDK.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<SigmonSDK.HTTPHeaders>
}
extension SigmonSDK.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SigmonSDK.HTTPHeader, b: SigmonSDK.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SigmonSDK.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SigmonSDK.HTTPHeader {
  public static func accept(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> SigmonSDK.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> SigmonSDK.HTTPHeader
  public static func authorization(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func contentType(_ value: Swift.String) -> SigmonSDK.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> SigmonSDK.HTTPHeader
}
extension SigmonSDK.HTTPHeaders {
  public static var `default`: SigmonSDK.HTTPHeaders
}
extension SigmonSDK.HTTPHeader {
  public static var defaultAcceptEncoding: SigmonSDK.HTTPHeader
  public static var defaultAcceptLanguage: SigmonSDK.HTTPHeader
  public static var defaultUserAgent: SigmonSDK.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: SigmonSDK.HTTPHeaders {
    get
    set(newValue)
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: SigmonSDK.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: SigmonSDK.HTTPHeaders {
    get
    set(newValue)
  }
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static var connect: SigmonSDK.HTTPMethod
  public static var delete: SigmonSDK.HTTPMethod
  public static var get: SigmonSDK.HTTPMethod
  public static var head: SigmonSDK.HTTPMethod
  public static var options: SigmonSDK.HTTPMethod
  public static var patch: SigmonSDK.HTTPMethod
  public static var post: SigmonSDK.HTTPMethod
  public static var put: SigmonSDK.HTTPMethod
  public static var query: SigmonSDK.HTTPMethod
  public static var trace: SigmonSDK.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : SigmonSDK.DataResponseSerializerProtocol, SigmonSDK.DownloadResponseSerializerProtocol {
  var dataPreprocessor: SigmonSDK.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : SigmonSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : SigmonSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension SigmonSDK.DataPreprocessor where Self == SigmonSDK.PassthroughPreprocessor {
  public static var passthrough: SigmonSDK.PassthroughPreprocessor {
    get
  }
}
extension SigmonSDK.DataPreprocessor where Self == SigmonSDK.GoogleXSSIPreprocessor {
  public static var googleXSSI: SigmonSDK.GoogleXSSIPreprocessor {
    get
  }
}
extension SigmonSDK.ResponseSerializer {
  public static var defaultDataPreprocessor: SigmonSDK.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: SigmonSDK.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension SigmonSDK.DownloadResponseSerializerProtocol where Self : SigmonSDK.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension SigmonSDK.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SigmonSDK.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SigmonSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SigmonSDK.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SigmonSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SigmonSDK.ResponseSerializer
}
extension SigmonSDK.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SigmonSDK.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SigmonSDK.ResponseSerializer
}
public struct URLResponseSerializer : SigmonSDK.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension SigmonSDK.DownloadResponseSerializerProtocol where Self == SigmonSDK.URLResponseSerializer {
  public static var url: SigmonSDK.URLResponseSerializer {
    get
  }
}
extension SigmonSDK.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : SigmonSDK.ResponseSerializer {
  final public let dataPreprocessor: SigmonSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod>
  public init(dataPreprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension SigmonSDK.ResponseSerializer where Self == SigmonSDK.DataResponseSerializer {
  public static var data: SigmonSDK.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.DataResponseSerializer
}
extension SigmonSDK.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension SigmonSDK.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : SigmonSDK.ResponseSerializer {
  final public let dataPreprocessor: SigmonSDK.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod>
  public init(dataPreprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension SigmonSDK.ResponseSerializer where Self == SigmonSDK.StringResponseSerializer {
  public static var string: SigmonSDK.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SigmonSDK.StringResponseSerializer
}
extension SigmonSDK.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension SigmonSDK.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : SigmonSDK.ResponseSerializer {
  final public let dataPreprocessor: SigmonSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: SigmonSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension SigmonSDK.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SigmonSDK.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension SigmonSDK.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static var value: SigmonSDK.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension SigmonSDK.Empty : SigmonSDK.EmptyResponse {
  public static func emptyValue() -> SigmonSDK.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : SigmonSDK.DataDecoder {
}
extension Foundation.PropertyListDecoder : SigmonSDK.DataDecoder {
}
final public class DecodableResponseSerializer<T> : SigmonSDK.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: SigmonSDK.DataPreprocessor
  final public let decoder: SigmonSDK.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod>
  public init(dataPreprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension SigmonSDK.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SigmonSDK.DecodableResponseSerializer<T> where Self == SigmonSDK.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension SigmonSDK.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension SigmonSDK.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SigmonSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SigmonSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SigmonSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SigmonSDK.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : SigmonSDK.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: SigmonSDK.DataDecoder
  public let dataPreprocessor: SigmonSDK.DataPreprocessor
  public init(decoder: SigmonSDK.DataDecoder = JSONDecoder(), dataPreprocessor: SigmonSDK.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : SigmonSDK.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : SigmonSDK.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension SigmonSDK.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: SigmonSDK.DataDecoder = JSONDecoder(), dataPreprocessor: SigmonSDK.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == SigmonSDK.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension SigmonSDK.DataStreamSerializer where Self == SigmonSDK.PassthroughStreamSerializer {
  public static var passthrough: SigmonSDK.PassthroughStreamSerializer {
    get
  }
}
extension SigmonSDK.DataStreamSerializer where Self == SigmonSDK.StringStreamSerializer {
  public static var string: SigmonSDK.StringStreamSerializer {
    get
  }
}
extension SigmonSDK.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SigmonSDK.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping SigmonSDK.DataStreamRequest.Handler<Serializer.SerializedObject, SigmonSDK.AFError>) -> Self where Serializer : SigmonSDK.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SigmonSDK.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: SigmonSDK.DataDecoder = JSONDecoder(), preprocessor: SigmonSDK.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping SigmonSDK.DataStreamRequest.Handler<T, SigmonSDK.AFError>) -> Self where T : Swift.Decodable
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: SigmonSDK.Request.State, b: SigmonSDK.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: SigmonSDK.EventMonitor?
  final public let interceptor: SigmonSDK.RequestInterceptor?
  weak public var delegate: SigmonSDK.RequestDelegate? {
    get
  }
  public var state: SigmonSDK.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: SigmonSDK.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: SigmonSDK.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: SigmonSDK.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SigmonSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SigmonSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: SigmonSDK.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: SigmonSDK.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension SigmonSDK.Request : Swift.Equatable {
  public static func == (lhs: SigmonSDK.Request, rhs: SigmonSDK.Request) -> Swift.Bool
}
extension SigmonSDK.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SigmonSDK.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SigmonSDK.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: SigmonSDK.Request)
  func retryResult(for request: SigmonSDK.Request, dueTo error: SigmonSDK.AFError, completion: @escaping (SigmonSDK.RetryResult) -> Swift.Void)
  func retryRequest(_ request: SigmonSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : SigmonSDK.Request {
  final public let convertible: SigmonSDK.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping SigmonSDK.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : SigmonSDK.Request {
  public typealias Handler<Success, Failure> = (SigmonSDK.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: SigmonSDK.DataStreamRequest.Event<Success, Failure>
    public let token: SigmonSDK.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(SigmonSDK.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: SigmonSDK.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: SigmonSDK.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping SigmonSDK.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension SigmonSDK.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: SigmonSDK.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : SigmonSDK.Request {
  public struct Options : Swift.OptionSet {
    public static var createIntermediateDirectories: SigmonSDK.DownloadRequest.Options
    public static var removePreviousFile: SigmonSDK.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = SigmonSDK.DownloadRequest.Options
    public typealias Element = SigmonSDK.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: SigmonSDK.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: SigmonSDK.DownloadRequest.Options = []) -> SigmonSDK.DownloadRequest.Destination
  public enum Downloadable {
    case request(SigmonSDK.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: SigmonSDK.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping SigmonSDK.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : SigmonSDK.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: SigmonSDK.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: SigmonSDK.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> SigmonSDK.UploadRequest.Uploadable
}
extension SigmonSDK.UploadRequest.Uploadable : SigmonSDK.UploadableConvertible {
  public func createUploadable() throws -> SigmonSDK.UploadRequest.Uploadable
}
public protocol UploadConvertible : SigmonSDK.URLRequestConvertible, SigmonSDK.UploadableConvertible {
}
final public class HMAC : SigmonSDK.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: SigmonSDK.HMAC.Error, b: SigmonSDK.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(SigmonSDK.SHA2.Variant)
    case sha3(SigmonSDK.SHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha384
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: SigmonSDK.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SigmonSDK.CTR : SigmonSDK.BlockMode {}
extension SigmonSDK.CCM : SigmonSDK.BlockMode {}
